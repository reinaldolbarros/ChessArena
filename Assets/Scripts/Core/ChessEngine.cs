using System.Collections.Generic;
using UnityEngine;
using System.Linq;

public class ChessEngine
{
    public readonly ChessPiece[,] Board;
    public ChessEngine() { Board = new ChessPiece[8, 8]; SetupInitialBoard(); }
    private void SetupInitialBoard() { for (int i = 0; i < 8; i++) { Board[i, 1] = new ChessPiece(PieceType.Pawn, PlayerColor.White, i, 1); Board[i, 6] = new ChessPiece(PieceType.Pawn, PlayerColor.Black, i, 6); } Board[0, 0] = new ChessPiece(PieceType.Rook, PlayerColor.White, 0, 0); Board[7, 0] = new ChessPiece(PieceType.Rook, PlayerColor.White, 7, 0); Board[1, 0] = new ChessPiece(PieceType.Knight, PlayerColor.White, 1, 0); Board[6, 0] = new ChessPiece(PieceType.Knight, PlayerColor.White, 6, 0); Board[2, 0] = new ChessPiece(PieceType.Bishop, PlayerColor.White, 2, 0); Board[5, 0] = new ChessPiece(PieceType.Bishop, PlayerColor.White, 5, 0); Board[3, 0] = new ChessPiece(PieceType.Queen, PlayerColor.White, 3, 0); Board[4, 0] = new ChessPiece(PieceType.King, PlayerColor.White, 4, 0); Board[0, 7] = new ChessPiece(PieceType.Rook, PlayerColor.Black, 0, 7); Board[7, 7] = new ChessPiece(PieceType.Rook, PlayerColor.Black, 7, 7); Board[1, 7] = new ChessPiece(PieceType.Knight, PlayerColor.Black, 1, 7); Board[6, 7] = new ChessPiece(PieceType.Knight, PlayerColor.Black, 6, 7); Board[2, 7] = new ChessPiece(PieceType.Bishop, PlayerColor.Black, 2, 7); Board[5, 7] = new ChessPiece(PieceType.Bishop, PlayerColor.Black, 5, 7); Board[3, 7] = new ChessPiece(PieceType.Queen, PlayerColor.Black, 3, 7); Board[4, 7] = new ChessPiece(PieceType.King, PlayerColor.Black, 4, 7); }
    public bool TryMovePiece(Vector2Int from, Vector2Int to) { ChessPiece piece = Board[from.x, from.y]; if (piece == null || !GetLegalMovesForPieceAt(from.x, from.y).Contains(to)) return false; Board[to.x, to.y] = piece; Board[from.x, from.y] = null; piece.X = to.x; piece.Y = to.y; return true; }
    public List<Vector2Int> GetLegalMovesForPieceAt(int x, int y) { ChessPiece piece = Board[x, y]; if (piece == null) return new List<Vector2Int>(); List<Vector2Int> pseudoLegalMoves = GetPseudoLegalMovesForPieceAt(x, y); List<Vector2Int> legalMoves = new List<Vector2Int>(); foreach (var move in pseudoLegalMoves) { ChessPiece originalPiece = Board[move.x, move.y]; Board[move.x, move.y] = piece; Board[x, y] = null; if (!IsKingInCheck(piece.Color)) legalMoves.Add(move); Board[x, y] = piece; Board[move.x, move.y] = originalPiece; } return legalMoves; }
    private List<Vector2Int> GetPseudoLegalMovesForPieceAt(int x, int y) { switch (Board[x, y].Type) { case PieceType.Pawn: return GetPawnMoves(Board[x, y]); case PieceType.Rook: return GetSlidingMoves(Board[x, y], new[] { Vector2Int.up, Vector2Int.down, Vector2Int.left, Vector2Int.right }); case PieceType.Bishop: return GetSlidingMoves(Board[x, y], new[] { new Vector2Int(1, 1), new Vector2Int(1, -1), new Vector2Int(-1, 1), new Vector2Int(-1, -1) }); case PieceType.Knight: return GetKnightMoves(Board[x, y]); case PieceType.Queen: return GetSlidingMoves(Board[x, y], new[] { Vector2Int.up, Vector2Int.down, Vector2Int.left, Vector2Int.right, new Vector2Int(1, 1), new Vector2Int(1, -1), new Vector2Int(-1, 1), new Vector2Int(-1, -1) }); case PieceType.King: return GetKingMoves(Board[x, y]); default: return new List<Vector2Int>(); } }
    private List<Vector2Int> GetPawnMoves(ChessPiece p) { List<Vector2Int> m = new List<Vector2Int>(); int dir = p.Color == PlayerColor.White ? 1 : -1; int start = p.Color == PlayerColor.White ? 1 : 6; int fwd1 = p.Y + dir; if (IsOnBoard(p.X, fwd1) && Board[p.X, fwd1] == null) { m.Add(new Vector2Int(p.X, fwd1)); if (p.Y == start && Board[p.X, p.Y + 2 * dir] == null) m.Add(new Vector2Int(p.X, p.Y + 2 * dir)); } int[] capX = { p.X - 1, p.X + 1 }; foreach (var x in capX) if (IsOnBoard(x, fwd1) && Board[x, fwd1] != null && Board[x, fwd1].Color != p.Color) m.Add(new Vector2Int(x, fwd1)); return m; }
    private List<Vector2Int> GetSlidingMoves(ChessPiece p, Vector2Int[] dirs) { List<Vector2Int> m = new List<Vector2Int>(); foreach (var d in dirs) for (int i = 1; i < 8; i++) { int nx = p.X + d.x * i, ny = p.Y + d.y * i; if (!IsOnBoard(nx, ny)) break; ChessPiece t = Board[nx, ny]; if (t == null) m.Add(new Vector2Int(nx, ny)); else { if (t.Color != p.Color) m.Add(new Vector2Int(nx, ny)); break; } } return m; }
    private List<Vector2Int> GetKnightMoves(ChessPiece p) { List<Vector2Int> m = new List<Vector2Int>(); int[] xOff = { 1, 1, 2, 2, -1, -1, -2, -2 }, yOff = { 2, -2, 1, -1, 2, -2, 1, -1 }; for (int i = 0; i < 8; i++) { int nx = p.X + xOff[i], ny = p.Y + yOff[i]; if (IsOnBoard(nx, ny)) { ChessPiece t = Board[nx, ny]; if (t == null || t.Color != p.Color) m.Add(new Vector2Int(nx, ny)); } } return m; }
    private List<Vector2Int> GetKingMoves(ChessPiece p) { List<Vector2Int> m = new List<Vector2Int>(); for (int x = -1; x <= 1; x++) for (int y = -1; y <= 1; y++) { if (x == 0 && y == 0) continue; int nx = p.X + x, ny = p.Y + y; if (IsOnBoard(nx, ny)) { ChessPiece t = Board[nx, ny]; if (t == null || t.Color != p.Color) m.Add(new Vector2Int(nx, ny)); } } return m; }
    private bool IsOnBoard(int x, int y) => x >= 0 && x < 8 && y >= 0 && y < 8;
    private Vector2Int FindKingPosition(PlayerColor c) { for (int x = 0; x < 8; x++) for (int y = 0; y < 8; y++) if (Board[x, y] != null && Board[x, y].Type == PieceType.King && Board[x, y].Color == c) return new Vector2Int(x, y); return new Vector2Int(-1, -1); }
    private bool IsSquareAttackedBy(Vector2Int sq, PlayerColor c) { for (int x = 0; x < 8; x++) for (int y = 0; y < 8; y++) { ChessPiece p = Board[x, y]; if (p != null && p.Color == c && GetPseudoLegalMovesForPieceAt(x, y).Contains(sq)) return true; } return false; }
    public bool IsKingInCheck(PlayerColor c) { Vector2Int kingPos = FindKingPosition(c); return kingPos.x != -1 && IsSquareAttackedBy(kingPos, c == PlayerColor.White ? PlayerColor.Black : PlayerColor.White); }
    public bool HasAnyLegalMoves(PlayerColor c) { for (int x = 0; x < 8; x++) for (int y = 0; y < 8; y++) if (Board[x, y] != null && Board[x, y].Color == c && GetLegalMovesForPieceAt(x, y).Any()) return true; return false; }
}